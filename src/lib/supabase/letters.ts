import { supabase } from '../../../lib/supabaseClient';
import { User } from '@supabase/supabase-js';

export interface Letter {
  id?: string; // UUID, generated by Supabase
  author_id: string; // UUID of the author (from auth.users or profiles)
  recipient_id?: string | null; // UUID of the recipient (from auth.users or profiles)
  content: string; // Assuming text for now, can be jsonb for rich editor
  is_draft: boolean;
  is_shared?: boolean;
  is_read?: boolean;
  shared_at?: string | null; // ISO timestamp
  read_at?: string | null; // ISO timestamp
  reading_mode?: string | null;
  unlock_at?: string | null; // ISO timestamp
  created_at?: string; // ISO timestamp, managed by Supabase
  updated_at?: string; // ISO timestamp, managed by Supabase
}

/**
 * Saves or updates a letter. If an ID is provided, it updates; otherwise, it creates.
 * Assumes 'letters' table has 'author_id', 'recipient_id', 'content', 'is_draft'.
 * Timestamps (created_at, updated_at) are typically handled by Supabase.
 */
export const saveLetter = async (letterData: Letter): Promise<{ data: Letter | null; error: any }> => {
  const { id, author_id, recipient_id, content, is_draft, ...otherFields } = letterData;

  if (!author_id) {
    return { data: null, error: { message: 'Author ID is required to save a letter.' } };
  }

  const letterPayload: Omit<Letter, 'id' | 'created_at' | 'updated_at'> & { updated_at?: string } = {
    author_id,
    recipient_id: recipient_id || null,
    content,
    is_draft,
    ...otherFields,
    updated_at: new Date().toISOString(), // Explicitly set updated_at for upsert
  };

  // DEBUG: Log current session before database operation
  const { data: { session: currentSessionDebug } } = await supabase.auth.getSession();
  console.log('[saveLetter] Current Supabase session before DB op:', currentSessionDebug);
  console.log('[saveLetter] User from session:', currentSessionDebug?.user?.id);
  console.log('[saveLetter] Role from session:', currentSessionDebug?.user?.role);

  let response;
  if (id) {
    // Update existing letter
    response = await supabase
      .from('letters')
      .update(letterPayload)
      .eq('id', id)
      .eq('author_id', author_id) // Ensure user can only update their own letters
      .select()
      .single();
  } else {
    // Create new letter
    response = await supabase
      .from('letters')
      .insert({ ...letterPayload, created_at: new Date().toISOString() } as any) // created_at for new inserts
      .select()
      .single();
  }

  return { data: response.data as Letter | null, error: response.error };
};

/**
 * Fetches letters by author. Can filter for drafts or all letters.
 * Assumes 'letters' table has 'author_id' and 'is_draft'.
 */
export const getLettersByAuthor = async (
  authorId: string,
  options: { draftsOnly?: boolean; sentOnly?: boolean } = {}
): Promise<{ data: Letter[]; error: any }> => {
  if (!authorId) {
    return { data: [], error: { message: 'Author ID is required to fetch letters.' } };
  }

  let query = supabase
    .from('letters')
    .select('*')
    .eq('author_id', authorId);

  if (options.draftsOnly) {
    query = query.eq('is_draft', true);
  } else if (options.sentOnly) {
    query = query.eq('is_draft', false); // Or perhaps based on 'is_shared'
  }

  query = query.order('updated_at', { ascending: false });

  const { data, error } = await query;
  return { data: data as Letter[], error };
};

/**
 * Fetches a single letter by its ID, ensuring it belongs to the specified author.
 * Assumes 'letters' table has 'author_id'.
 */
export const getLetterById = async (letterId: string, authorId: string): Promise<{ data: Letter | null; error: any }> => {
  if (!letterId || !authorId) {
    return { data: null, error: { message: 'Letter ID and Author ID are required.' } };
  }

  const { data, error } = await supabase
    .from('letters')
    .select('*')
    .eq('id', letterId)
    .eq('author_id', authorId) // Security check: user can only fetch their own letter
    .single();

  return { data: data as Letter | null, error };
};
